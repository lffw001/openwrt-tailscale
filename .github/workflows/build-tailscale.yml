name: Smaller Tailscale Build Pipeline

on:
  workflow_dispatch: 
  repository_dispatch:
    types: [ build-tailscale ]

permissions:
  contents: read

env:
  SOFTWARE_NAME: "Tailscale"
  FILE_NAME: "tailscaled"
  REPO: "tailscale/tailscale"
  REPO_SMALL: "GuNanOvO/openwrt-tailscale"
  REPO_SMALL_NAME: "openwrt-tailscale"
  REPO_SMALL_OWNER: "GuNanOvO"
  ARTIFACT_DIR: "artifacts"
  BUILD_DATE: ""

jobs:
  prepare-tools:
    name: Prepare UPX and Go
    runs-on: ubuntu-latest
    outputs:
      upx_tag: ${{ steps.set_upx_path.outputs.upx_tag }}
      upx_ver: ${{ steps.set_upx_path.outputs.upx_ver }}
      go_version: ${{ steps.set_go_path.outputs.go_version }}
    steps:
      # ----------------- UPX -----------------
      - name: Check UPX Latest Version
        id: check_upx
        run: |
          UPX_TAG=$(curl -s https://api.github.com/repos/upx/upx/releases/latest \
            | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          UPX_VER="${UPX_TAG#v}"
          echo "Detected UPX Version: $UPX_TAG"
          
          # 设置为步骤输出
          echo "upx_tag=$UPX_TAG" >> "$GITHUB_OUTPUT"
          echo "upx_ver=$UPX_VER" >> "$GITHUB_OUTPUT"
          
          # 同时也设置为环境变量供后续步骤使用
          echo "UPX_TAG=$UPX_TAG" >> "$GITHUB_ENV"
          echo "UPX_VER=$UPX_VER" >> "$GITHUB_ENV"

      - name: Cache UPX
        id: cache_upx
        uses: actions/cache@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.upx_tag }}

      - name: Prepare UPX
        if: steps.cache_upx.outputs.cache-hit != true
        run: |
          UPX_URL="https://github.com/upx/upx/releases/download/${{ steps.check_upx.outputs.upx_tag }}/upx-${{ steps.check_upx.outputs.upx_ver }}-amd64_linux.tar.xz"
          echo "Downloading UPX from: $UPX_URL"
          mkdir -p upx
          curl -L -o upx.tar.xz "$UPX_URL"
          tar -xf upx.tar.xz -C upx --strip-components=1
          chmod +x upx/upx
          rm -f upx.tar.xz

      - name: Save UPX
        if: steps.cache_upx.outputs.cache-hit != true
        id: cache_upx_save
        uses: actions/cache/save@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.upx_tag }}

      # ----------------- Go -----------------
      - name: Check Go Latest Version
        id: check_go
        run: |
          GO_VERSION=$(curl -s https://go.dev/VERSION?m=text | head -1)
          echo "Detected Go Version: $GO_VERSION"
          
          # 设置为步骤输出
          echo "go_version=$GO_VERSION" >> "$GITHUB_OUTPUT"
          
          # 同时也设置为环境变量
          echo "GO_VERSION=$GO_VERSION" >> "$GITHUB_ENV"

      - name: Cache Go
        id: cache_go
        uses: actions/cache@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.go_version }}

      - name: Prepare Go
        if: steps.cache_go.outputs.cache-hit != true
        run: |
          GO_OS=linux
          GO_ARCH=amd64
          GO_URL="https://go.dev/dl/${{ steps.check_go.outputs.go_version }}.$GO_OS-$GO_ARCH.tar.gz"
          echo "Downloading Go from: $GO_URL"
          mkdir -p go
          curl -L -o go.tar.gz "$GO_URL"
          tar -C go -xzf go.tar.gz --strip-components=1
          rm -f go.tar.gz
      
      - name: Save Go
        if: steps.check_go.outputs.cache-hit != true
        id: cache_go_save
        uses: actions/cache/save@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.go_version }}

  build:
    name: Build for ${{ matrix.platform }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ env.PKG_VERSION }}
      date: ${{ env.BUILD_DATE }}
    needs: prepare-tools
    env:
      UPX_TAG: ${{ needs.prepare-tools.outputs.upx_tag }}
      GO_VERSION: ${{ needs.prepare-tools.outputs.go_version }}
    strategy:
      matrix:
        sdk:
          - 24.10.4
        platform:
          - 'aarch64_cortex-a53'
          - 'aarch64_cortex-a72'
          - 'aarch64_cortex-a76'
          - 'aarch64_generic'
          - 'arm_arm1176jzf-s_vfp'
          - 'arm_arm926ej-s'
          - 'arm_cortex-a15_neon-vfpv4'
          - 'arm_cortex-a5_vfpv4'
          - 'arm_cortex-a7'
          - 'arm_cortex-a7_neon-vfpv4'
          - 'arm_cortex-a7_vfpv4'
          - 'arm_cortex-a8_vfpv3'
          - 'arm_cortex-a9'
          - 'arm_cortex-a9_neon'
          - 'arm_cortex-a9_vfpv3-d16'
          - 'arm_fa526'
          - 'arm_xscale'
          - 'i386_pentium-mmx'
          - 'i386_pentium4'
          - 'loongarch64_generic'
          - 'mips64_mips64r2'
          - 'mips64_octeonplus'
          - 'mips64el_mips64r2'
          - 'mips_24kc'
          - 'mips_4kec'
          - 'mips_mips32'
          - 'mipsel_24kc'
          - 'mipsel_24kc_24kf'
          - 'mipsel_74kc'
          - 'mipsel_mips32'
          - 'riscv64_riscv64'
          - 'x86_64'
      fail-fast: true

    steps:
      - name: Set build timestamp
        run: |
          echo "BUILD_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          path: repo

      - name: Prepare package
        run: |
          VERSION=$(sed -n 's/^PKG_VERSION:=\(.*\)/\1/p' repo/package/tailscale/Makefile | tr -d '[:space:]')
          RELEASE=$(sed -n 's/^PKG_COMMIT:=\(.*\)/\1/p' repo/package/tailscale/Makefile | tr -d '[:space:]')
          
          echo "PKG_VERSION=$VERSION" >> $GITHUB_ENV
          echo "PKG_COMMIT=$RELEASE" >> $GITHUB_ENV
          
          mkdir tailscale
          cp -r repo/package/tailscale/. tailscale/
          
          echo "Parsed version: $VERSION"
          echo "Parsed release: $RELEASE"

      - name: Restore UPX from cache
        uses: actions/cache@v4
        id: cache-upx
        with:
          path: upx
          key: upx-linux-amd64-${{ env.UPX_TAG }}

      - name: Restore Go from cache
        uses: actions/cache@v4
        id: cache-go
        with:
          path: go
          key: go-linux-amd64-${{ env.GO_VERSION }}

      # BUILD

      - name: Pull OpenWRT SDK Docker image
        run: |
          docker pull ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ matrix.sdk }}

      - name: Prepare build
        run: |
          mkdir -p bin
          mkdir -p "${{ env.ARTIFACT_DIR }}"
          chmod -R 777 bin || true
          ls -la

      - name: Build with OpenWRT SDK Docker
        run: |
          cat > build_script.sh << 'BUILD_SCRIPT_END'
          #!/bin/bash
          set -e
          cd /builder
          
          ./scripts/feeds update packages > /dev/null
          ./scripts/feeds install golang > /dev/null
          
          mkdir -p /builder/package/lang
          # ln -sf /builder/feeds/packages/lang/golang /builder/package/lang/golang
          
          rm -rf /builder/package/tailscale
          mkdir -p /builder/package/tailscale
          cp -r /builder/tailscale/. /builder/package/tailscale/
          
          make defconfig > /dev/null 2>&1

          [ -f /builder/go/bin/go ] || { echo "Error: Go binary missing"; exit 1; }
          
          mkdir -p /builder/staging_dir/hostpkg/bin
          ln -sf /builder/go/bin/go /builder/staging_dir/hostpkg/bin/go
          ln -sf /builder/go/bin/gofmt /builder/staging_dir/hostpkg/bin/gofmt
          
          if [ -d /builder/staging_dir/hostpkg/lib/go-cross/bin ]; then
            ln -sf /builder/go/bin/go /builder/staging_dir/hostpkg/lib/go-cross/bin/go
          fi
          
          echo "Using $(/builder/go/bin/go version)"
          
          make package/tailscale/compile V=s
          
          IPKS=$(find bin/packages bin/targets -name "tailscale_*.ipk" -type f)
          if [ -n "$IPKS" ]; then
            echo "Build Success:"
            ls -lh $IPKS
          else
            echo "Error: No IPK found" && exit 1
          fi
          BUILD_SCRIPT_END
          
          docker run --rm \
            -v "$(pwd)/bin:/builder/bin:z" \
            -v "$(pwd)/tailscale:/builder/tailscale:ro,z" \
            -v "$(pwd)/upx:/builder/upx:ro,z" \
            -v "$(pwd)/go:/builder/go:ro,z" \
            -v "$(pwd)/build_script.sh:/build_script.sh:ro,z" \
            -e TERM=xterm \
            -e FORCE=1 \
            ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ matrix.sdk }} \
            bash /build_script.sh

      # UPLOAD

      - name: Collect build artifacts
        shell: bash
        run: |
          mkdir -p "${{ env.ARTIFACT_DIR }}"

          echo "Searching for IPK for platform: ${{ matrix.platform }}..."
          
          if [ -d "bin/packages/${{ matrix.platform }}" ]; then
            mapfile -t ipk_files < <(find "bin/packages/${{ matrix.platform }}" -name "tailscale_*.ipk" -type f)
          else
            mapfile -t ipk_files < <(find bin -name "tailscale_*.ipk" -type f)
          fi

          if [ ${#ipk_files[@]} -eq 0 ]; then
            echo "::error::No IPK files found for ${{ matrix.platform }}!"
            exit 1
          fi

          source_ipk=$(ls -t "${ipk_files[@]}" | head -n 1)
          
          target_ipk="${{ env.ARTIFACT_DIR }}/tailscale_${{ env.PKG_VERSION }}_${{ matrix.platform }}.ipk"

          echo "Found IPK: $source_ipk"
          echo "Collecting to: $target_ipk"
          
          cp -v "$source_ipk" "$target_ipk"

          if [ ! -s "$target_ipk" ]; then
            echo "::error::Artifact collection failed: $target_ipk is missing or empty!"
            exit 1
          fi

          echo "Success: Artifact ready in ${{ env.ARTIFACT_DIR }}"
          ls -lh "${{ env.ARTIFACT_DIR }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: tailscale_${{ env.PKG_VERSION }}_${{ matrix.platform }}
          path: ${{ env.ARTIFACT_DIR }}/
          if-no-files-found: error
          retention-days: 30

  release:
    name: Create Release
    needs: [build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      RELEASE_TAG: v${{ needs.build.outputs.version }}
      VERSION: ${{ needs.build.outputs.version }}
      BUILD_DATE: ${{ needs.build.outputs.date }}
      ARTIFACT_DIR: "release_assets"
    steps:
      - name: Prepare workspace
        run: mkdir -p ${{ env.ARTIFACT_DIR }}

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: temp_artifacts

      - name: Organize and Generate Files
        run: |
          JSON_FILE="${{ env.ARTIFACT_DIR }}/artifacts.json"
          PACKAGES_FILE="${{ env.ARTIFACT_DIR }}/Packages"
          
          echo "[" > "$JSON_FILE"
          : > "$PACKAGES_FILE" # 使用 : > 清空文件更简洁
          
          first=true
          # 遍历所有下载的 artifacts 目录
          for dir in temp_artifacts/*/; do
            [ -d "$dir" ] || continue
            
            ipk_path=$(find "$dir" -name "tailscale_*.ipk" -type f | head -n 1)
            [ -z "$ipk_path" ] && continue
            
            ipk_name=$(basename "$ipk_path")
            
            # 改进后的架构提取逻辑：提取第3个下划线之后的部分
            arch=$(echo "$ipk_name" | cut -d'_' -f3- | sed 's/\.ipk$//')
            
            # 复制 IPK 到发布目录
            cp "$ipk_path" "${{ env.ARTIFACT_DIR }}/"
            
            echo "Processing $ipk_name for $arch..."
            
            # 提取 control 内容
            CONTROL_CONTENT=$(tar -xOzf "$ipk_path" ./control.tar.gz | tar -xOzf - ./control 2>/dev/null || \
                              tar -xOzf "$ipk_path" control.tar.gz | tar -xOzf - control)
            # 计算文件大小和 SHA256
            FILE_SIZE=$(stat -c%s "$ipk_path")
            FILE_SHA256=$(sha256sum "$ipk_path" | awk '{print $1}')
            
            # 组合写入 Packages
            # 使用 sed 确保每个 control 段落后都有换行符，避免字段粘连
            {
              echo "$CONTROL_CONTENT" | sed '$a\' 
              echo "Filename: $ipk_name"
              echo "Size: $FILE_SIZE"
              echo "SHA256sum: $FILE_SHA256"
              echo "" 
            } >> "$PACKAGES_FILE"
            
            # 写入 JSON
            if [ "$first" = true ]; then
              first=false
            else
              echo "," >> "$JSON_FILE"
            fi
            echo "{\"target\":\"${arch}\",\"ipk\":\"${ipk_name}\",\"sha256\":\"${FILE_SHA256}\"}" >> "$JSON_FILE"
          done
          
          echo "]" >> "$JSON_FILE"

          echo "${{ env.VERSION }}" > "${{ env.ARTIFACT_DIR }}/version"
          
          # 生成 Packages.gz
          gzip -kf "$PACKAGES_FILE"
      
      - name: Setup Usign
        run: |
          git clone --depth 1 https://git.openwrt.org/project/usign.git
          cd usign && mkdir build && cd build
          cmake .. && make -j$(nproc) && sudo make install

      - name: Deploy to Feed Branch
        env:
          USIGN_SECRET_KEY_B64: ${{ secrets.USIGN_SECRET_KEY_B64 }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. 配置 Git 用户信息
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # 删除本地 feed 分支
          mkdir deploy_workspace
          cd deploy_workspace
          git init

          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git checkout --orphan feed

          # 创建 orphan 分支
          git fetch origin main --depth=1
          git checkout origin/main -- feed_template/

          cp -r feed_template/* ./
          rm -rf feed_template

          # 创建 .nojekyll
          touch .nojekyll
          
          # 拷贝新生成的文件
          cp ../${{ env.ARTIFACT_DIR }}/tailscale_*.ipk ./
          cp ../${{ env.ARTIFACT_DIR }}/Packages ./
          cp ../${{ env.ARTIFACT_DIR }}/Packages.gz ./

          # 签名逻辑
          echo "$USIGN_SECRET_KEY_B64" | base64 -d > key-build.sec
          usign -S -m Packages -s key-build.sec -x Packages.sig
          rm -f key-build.sec

          generate_tbody() {
            echo "          <tbody>"
            for file in Packages* tailscale*; do
              [ -f "${file}" ] || continue
              fname=$(basename "${file}")
              fsize=$(du -h "${file}" | cut -f1)
              fdate=$(date -r "${file}" +"%Y-%m-%d %a %H:%M:%S UTC")
              echo "                        <tr>"
              echo "                            <td><a href=\"$fname\">$fname</a></td>"
              echo "                            <td>$fsize</td>"
              echo "                            <td>$fdate</td>"
              echo "                        </tr>"
            done
            echo "          </tbody>"
          }

          
          generate_tbody > tbody.tmp
          sed -i '/<!-- tbody-anchor -->/,/<!-- end-tbody-anchor -->/ {
            /<!-- tbody-anchor -->/!{
              /<!-- end-tbody-anchor -->/!d
            }
          }' index.html
          sed -i '/<!-- tbody-anchor -->/r tbody.tmp' index.html
            
          current_date="${{ env.BUILD_DATE }}"
          sed -i '/<!-- date-anchor -->/,/<!-- end-date-anchor -->/ {
              /<span id="date">/ {
                  s#<span id="date">.*</span>#<span id="date">'"${current_date}"'</span>#
              }
          }' index.html

          version=$(echo "${{ env.RELEASE_TAG }}" | sed 's/^v//')
          sed -i '/<!-- version-anchor -->/,/<!-- end-version-anchor -->/ {
              /<span id="version">/ {
                  s#<span id="version">.*</span>#<span id="version">'"${version}"'</span>#
              }
          }' index.html

          rm -f tbody.tmp

          git add -A
          git commit -m "Update feed: ${{ env.BUILD_DATE }}"
          git push origin feed --force

      - name: Generate release markdown
        id: generate_release_markdown
        run: |
          # 读取 artifacts.json 并生成简单的 markdown 表格
          artifacts_file="${{ env.ARTIFACT_DIR }}/artifacts.json"
          if [[ ! -f "${artifacts_file}" ]]; then
            echo "Error: artifacts.json missing"
            exit 1
          fi
          
          owner="${{ env.REPO_SMALL_OWNER }}"
          repo="${{ env.REPO_SMALL_NAME }}"
          tag="${{ env.RELEASE_TAG }}"
          
          # 构建 Markdown 表格
          table="| Target Platform / 目标平台 | IPK Package (Direct Link) |\n|:--- |:--- |"
          rows=$(jq -r --arg owner "$owner" --arg repo "$repo" --arg tag "$tag" '
          .[] | "| \(.target) | [\(.ipk)](https://github.com/\($owner)/\($repo)/releases/download/\($tag)/\(.ipk)) |"
          ' ${artifacts_file})
          full_table="${table}\n${rows}"

          # 设置 Release Body
          release_body="
          ## Smaller Tailscale / 更小的Tailscale  
          #### Version / 版本 : ${{ env.RELEASE_TAG }}
          #### Build Date / 构建日期 : ${{ env.BUILD_DATE }}
          #### Upstream Changelog / 上游更新日志 : [https://tailscale.com/changelog](https://tailscale.com/changelog)
          ---

          #### 本项目是为 OpenWRT 构建的 Tailscale 精简版本，使用官方 SDK 编译，旨在降低存储空间占用。    
          - 使用 OpenWRT 官方 SDK 编译。  
          - 采用 UPX 压缩技术大幅缩小二进制体积。  
          - 标准 IPK 格式，支持 opkg 直接安装。  

          #### Minimalistic Tailscale build for OpenWRT using the official SDK.  
          - Compiled with official OpenWRT SDK.  
          - Significant size reduction via UPX compression.  
          - Standard IPK format for direct opkg installation.  

          #### Architecture Check / 架构查询  
          Run the following command on your device to confirm target platform:  
          \`\`\`bash
          opkg print-architecture
          \`\`\`

          ---
        
          #### Download Links / 下载清单
          > [!IMPORTANT]
          > 请根据设备架构选择对应的安装包。
          > Please select the correct package for your device architecture.

          <details open>
          <summary>Package List / 文件列表</summary>

          ${full_table}

          </details>
          "

          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "${release_body}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "Smaller ${{ env.SOFTWARE_NAME }} ${{ env.RELEASE_TAG }}"
          body: ${{ steps.generate_release_markdown.outputs.release_body }}
          files: |
            ${{ env.ARTIFACT_DIR }}/*.ipk
            ${{ env.ARTIFACT_DIR }}/Packages
            ${{ env.ARTIFACT_DIR }}/Packages.gz
            ${{ env.ARTIFACT_DIR }}/artifacts.json
            ${{ env.ARTIFACT_DIR }}/version

      - name: Sync to small repo
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.git.createTag({
              owner: '${{ env.REPO_SMALL_OWNER }}',
              repo: '${{ env.REPO_SMALL_NAME }}',
              tag: '${{ env.RELEASE_TAG }}',
              message: 'Release ${{ env.RELEASE_TAG }}',
              object: '${{ github.sha }}',
              type: 'commit'
            })